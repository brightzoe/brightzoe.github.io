# 浏览器

## 浏览器缓存

### 为什么需要缓存

- 减少服务器负担
- 加快客户端网页加载速度

### 缓存位置（优先级从高到低）

- Service Worker 运行在 JavaScript 主线程之外，无法直接访问 DOM。可以自由地控制缓存，可以完成离线缓存、消息推送、网络代理等功能。
- Memory Cache 内存缓存效率最快，但持续性短，关闭 Tab 页，内存缓存就会被释放。
- Disk Cache 硬盘缓存，读取速度慢，容量大，持续性长。所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。

### 强缓存与协商缓存

强缓存：如果缓存资源有效则直接使用缓存资源，不必再次向服务器发送请求。

- Expires。HTTP 响应头添加 Expires，表示资源的过期时间。是 HTTP 1.0 的方式，在 HTTP 1.1 中已经被弃用。
- Cache-Control。响应头。Http 1.1 提出，对缓存更精准的控制，优先级高于 Expires。
  - max-age=：设置缓存的最大有效期，单位为秒。
  - private：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的 HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存。
  - no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源
  - no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源

协商缓存：如果命中强制缓存，无需发起请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。

- Last-Modified。HTTP 响应头添加 Last-Modified，表示资源的最后修改时间。下一次资源请求时，浏览器会在请求头中添加一个 If-Modified-Since，值为上一次服务器返回的 Last-Modified 的值。服务器比较这个值与最新资源的修改时间。如果未修改则返回 304，浏览器使用本地资源。如果已修改，返回 200 最新资源。缺点是时间精确度为秒级，有误差。
- ETag。响应头，表示资源生成的唯一标识符，如果资源改变则会变化。下一次请求，请求头添加 If-None-Match ，值为上一次服务器返回的 ETag 的值。服务器进行比较，比 Last-Modified 更精确，优先级也更高。

强缓存与协商缓存的区别在于：强缓存资源有效时直接使用缓存，不再向服务器发送请求，无效才会发送请求。而协商缓存都要发送请求判断缓存是否有效。
:::tip

命中协商缓存策略:Cache-Control 的 max-age 过期或为 no-cache。先向服务器发送一个请求，如果资源没有发生修改则返回 304 ，让浏览器使用缓存。如果资源发生修改则返回修改后的资源。

:::

### 缓存机制

强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

- 第一次加载资源，返回 200，浏览器下载资源，缓存资源与响应头。
- 下一次加载资源，强缓存优先级较高，浏览器先比较当前时间与上一次 返回 200 的时间差是否超过 Cache-Control 的 max-age，未超过则命中强缓存，不需要发送请求。不支持 Cache-Control 则使用 expires 判断是否过期。
- 资源已过期则开始协商缓存，向服务器发送 If-None-Match / If-Modified-Since 的请求。服务器收到请求后优先根据 ETag 比较 If-None-Match 的值是否一致，如果一致没有修改则返回 304，命中协商缓存。不一致则返回 200 以及最新资源。
- 如果请求头没有 If-None-Match，则根据 If-Modified-Since 比较 Last-Modified 的值是否一致，如果一致没有修改则返回 304，不一致则返回 200。

> 很多网站的资源后面都添加版本号，目的是每次升级资源后强制改变版本号，防止浏览器进行缓存。

## 浏览器多标签页通信

- WebSocket 使用服务器作为中介，标签页向服务器发送数据，服务器向其他标签页进行推送转发。
- SharedWorker
- localStorage 监听 localStorage 的变化。
- postMessage 获取对应标签页的引用，使用 postMessage 发送数据。

## Serveice Worker

运行在浏览器背后的独立线程，一般用来实现缓存功能。Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

实现缓存功能：

1. 注册 Service Worker
2. 监听到 install 后直接缓存需要的文件
3. 用户访问的时候拦截请求，查询是否存在缓存，存在缓存的话可以直接读取缓存文件，否则去请求数据

## 浏览器架构

多进程

- 浏览器进程。控制主框架部分，包括地址栏，前进后退等按钮，也处理高权限任务，比如网络请求，访问文件等。
- 渲染器进程。控制显示的任何内容为每个标签运行多个渲染器进程。
- 插件进程。
- GPU 进程。在独立的进程中处理 GPU 任务，GPU 要处理来自多个应用的请求，在同一个界面中绘制图形。

特点：

- 多进程保证健壮性。
- 安全，限制某些进程的功能，进行沙箱处理。
- 节省内存。根据情况拆分更多的进程或聚合为更少的进程。

## 浏览器渲染

### 渲染流水线

通过渲染器模块渲染。渲染机制比较复杂，分为很多子阶段，这个处理流程被称为渲染流水线。
![渲染流水线](https://s2.loli.net/2022/05/11/miD4AoXvFrjwOgH.png)

- 构建 DOM 树

  渲染引擎内部，有个叫 HTML 解析器（HTMLParser）的模块，负责将 HTML 字节流转换成 DOM 结构。

- 构建 CSSOM 树

- 构建渲染树

  DOM 树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的 CSS 样式规则并应用。

  不可见的元素当然就不会在这棵树中出现了。display 等于 none 的也不会被显示在这棵树里头，但是 visibility 等于 hidden 的元素是会显示在这棵树里头的。

- 布局

  从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

- 分层

  3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等复杂效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一颗对应的图层树（Layer Tree）。

- 渲染树绘制

#### CSS 间接影响 DOM 解析

- 解析 DOM 时，遇到 js 会暂停 DOM 解析先去执行 js 脚本。
- 执行 js 脚本时，如果当前页面有引用外部 css 或内联 css，渲染引擎要先把 CSS 转换为 CSSOM，因为 js 有修改 CSSOM 的能力。执行 JavaScript 之前还依赖 CSSOM。也就是说 CSS 会间接阻塞 DOM 的解析

### 回流和重绘

- 回流 reflow
  元素的几何尺寸变化，需要重新验证并计算渲染树。

- 重绘 repaint
  元素部分内容变化，不影响整体布局，比如背景色变化，不影响元素的尺寸位置。

> display:none 会触发回流，visibility:hidden 会触发重绘，没有尺寸和位置变化。

有些情况浏览器不会立即 reflow 或 repaint，而是批量进行 reflow，成为增量异步 reflow。浏览器自身针对回流重绘的优化：渲染队列机制。

### 渲染优化

JavaScript

- script 标签 放在 body 最后
- 使用 async/defer 属性

CSS

- link 方式引入

CSSOM DOM

- HTML/CSS 层级不要过深
- 尽量使用语义化标签

减少回流和重绘

- 不要使用 table 布局
- 尽可能修改类名而不是样式
- 避免频繁操作 DOM ,可以创建文档片段 documentFragment，应用好再添加到 DOM 中

## Reference

- [前端进阶高薪必看-浏览器篇 - 掘金](https://juejin.cn/post/7086015741429809188#heading-4)
- [【干货】十分钟读懂浏览器渲染流程 - 掘金](https://juejin.cn/post/6844903565610188807#heading-3)
- [浏览器渲染流程 - 掘金](https://juejin.cn/post/7090436813445136397)
