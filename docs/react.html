<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-react/README">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">React | brightzoe&#x27;s blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://brightzoe.top/docs/react"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="React | brightzoe&#x27;s blog"><meta data-rh="true" name="description" content="react 与 react-dom库"><meta data-rh="true" property="og:description" content="react 与 react-dom库"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://brightzoe.top/docs/react"><link data-rh="true" rel="alternate" href="https://brightzoe.top/docs/react" hreflang="en"><link data-rh="true" rel="alternate" href="https://brightzoe.top/docs/react" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="brightzoe&#39;s blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="brightzoe&#39;s blog Atom Feed">
<link rel="alternate" type="application/json" href="/blog/feed.json" title="brightzoe&#39;s blog JSON Feed"><link rel="stylesheet" href="/assets/css/styles.55dff740.css">
<link rel="preload" href="/assets/js/runtime~main.ef263209.js" as="script">
<link rel="preload" href="/assets/js/main.6c773390.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_XPEc" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_amhU themedImage--light_azui" height="40" width="40"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_amhU themedImage--dark_aDRF" height="40" width="40"></div><b class="navbar__title text--truncate">brightzoe</b></a><a class="navbar__item navbar__link" href="/docs/fe-basic/html">FE Basic</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/react">React</a><a class="navbar__item navbar__link" href="/docs/vue">Vue</a><a class="navbar__item navbar__link" href="/docs/data-structure">算法</a><a class="navbar__item navbar__link" href="/docs/business">业务</a><a class="navbar__item navbar__link" href="/docs/tools/chrome-devtools">工具</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/brightzoe" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_X57z colorModeToggle_XTd6"><button class="clean-btn toggleButton_MdH4 toggleButtonDisabled_bV2N" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_lgW4"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_Yk_4"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ipaQ"><div class="navbar__search searchBarContainer_G8xq"><input placeholder="Search" aria-label="Search" class="navbar__search-input"><div class="loadingRing_qMmc searchBarLoadingRing_mJGn"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_by_Y docsWrapper_mZIm"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_mlwx" type="button"></button><div class="docPage_IPNe"><aside class="theme-doc-sidebar-container docSidebarContainer_nEYl"><div class="sidebarViewport_kiNO"><div class="sidebar_sNTL"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_QWRJ"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/react">React</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/react/hooks">React Hooks</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/react/advanced-react/useState">React 进阶</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/react/controlled-and-uncontrolled-components">受控组件与非受控组件</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/react/design-pattern-and-best-practices">React 设计模式和最佳实践</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/react/pass-params-in-react">react-router 前端路由传参方式</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/react/where-to-save-data-in-react">如何存储 React 中的数据和状态</a></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_v9jn"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_RsHh"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_vbz6"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_WoA4"><div class="docItemContainer_SOrW"><article><div class="tocCollapsible_BKud theme-doc-toc-mobile tocMobile_iUJ6"><button type="button" class="clean-btn tocCollapsibleButton_J9Tx">On this page</button></div><div class="theme-doc-markdown markdown"><h1 id="react">React</h1><h2 id="react-与-react-dom库"><code>react</code> 与 <code>react-dom</code>库</h2><p><code>react</code> package contains only the functionality necessary to define React components. It is typically used together with a React renderer like react-dom for the web.</p><p><code>react-dom</code> package serves as the entry point to the DOM and server renderers for React.</p><pre><code class="language-js">import ReactDOM from &#x27;react-dom&#x27;;
ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));
</code></pre><h2 id="react-router-与-react-router-dom库"><code>react-router</code> 与 <code>react-router-dom</code>库</h2><p><code>react-router</code>是路由核心库。<code>react-router-dom</code>基于<code>react-router</code>，加入了一些在浏览器运行的功能，与 dom 相关。一般二者要一起使用。</p><h2 id="问题汇总">问题汇总</h2><h3 id="react-特点">React 特点</h3><p>JSX 语法</p><p>单向数据流</p><p>虚拟 DOM</p><p>组件化</p><h3 id="虚拟-dom">虚拟 DOM</h3><p>虚拟 DOM 是用来描述 DOM 结构的 js 对象，不是真实 DOM，与真实的 DOM 一一对应。使用的目的是为了更好地比较 DOM 的变化，不直接更新 DOM。</p><p>真实 DOM 更新缓慢，会直接更新 HTML，操作代价高，引起页面回流和重绘，消耗内存多。</p><p>虚拟 DOM：</p><ol><li>react 中数据发生改变，虚拟 DOM 重新渲染。</li><li>计算虚拟 DOM 与之前虚拟 DOM 的差异。</li><li>将 DOM 的变化用于更新真实 DOM。</li></ol><p>虚拟 DOM 一定更快吗？</p><p>不是的。虚拟 DOM 会有大量的计算，不一定比直接操作 DOM 更快。虚拟 DOM 提高了代码的性能下限，优化了大量操作 DOM 的性能损耗。</p><h3 id="class-comp-与-function-comp">Class Comp 与 Function Comp</h3><ol><li><p>类组件相对<strong>复杂</strong>，并且含有 this，比较难以理解。在一个生命周期函数中，可能有很多不想管的逻辑，而函数组件可以按照代码的用途拆分，做到关注点分离。</p></li><li><p>类组件相对较大，从长远角度难以维护，而 Hooks 组件相对较短，更容易拆分，可读性高也更方便维护。</p></li><li><p>函数组件<strong>复用成本低</strong>，更容易抽象出单独的组件或单独的逻辑。</p></li><li><p>函数组件更加灵活，更适合做到逻辑和 UI 的解耦。但类组件的逻辑也更清晰：构造函数以及生命周期的角度。</p></li><li><p>思考模式不同。</p><p>Class 组件的模式是先做什么再做什么，按照时间维度划分，比如 this.setState 的第二个参数，比如生命周期的使用。</p><p>函数组件的思考模式是依赖，副作用。围绕着 state，props 的变化而做什么事情。</p></li></ol><blockquote><p>函数式组件捕获了渲染所使用的值。hooks 追求的是渲染一致性，当执行一些方法时，读到的 state,props 是当时的状态快照，是不可变的。而类组件有 this，this.state/this.props 上的值都是变化的。---- <a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同？ — Overreacted</a></p></blockquote><h3 id="使用区别">使用区别</h3><p>class 组件</p><ol><li>需要继承。</li><li>有组件实例。</li><li>有生命周期函数。</li><li>有状态。</li></ol><p>Function 组件</p><ol><li>无需继承。</li><li>不是 new 出来的，没有实例。React 内部有表示该组件的对象。</li><li>没有生命周期函数。</li><li>以前没有状态，现在 useState 算是它的状态。</li></ol><h3 id="react-元素与组件">React 元素与组件</h3><p>react 组件可以用 jsx 创建，（jsx 是<code>React.createElement</code>的简写），是 react 中的最小单位，并不是真实的 dom，实际是一个 js 对象。</p><p>组件由元素构成，元素的数据结构是对象，而组件的数据结构是类或函数。</p><h3 id="purecomponent">PureComponent</h3><p>自动调用 shouldComponentUpdate，比较 props 和 state，如果没有变化，不会调用 render。</p><p>使用 Object.is 进行浅比较。</p><h3 id="生命周期">生命周期</h3><p><img src="https://s2.loli.net/2022/05/02/AcLCE2GQ8WsPOjh.png"></p><ul><li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">React lifecycle methods diagram</a></li></ul><p>挂载阶段</p><ol><li>constructor 初始化 state，进行方法绑定</li><li>static getDerivedStateFormProps 在初始挂载及后续更新都会被调用，返回一个对象来更新 state，state 的值在任何时候都取决于 props, 如果返回 null 则不更新任何内容。</li><li>render 渲染组件</li><li>componentDidMount 在组件第一次挂载完成（渲染到 DOM）后调用，只会被调用一次</li></ol><p>更新阶段</p><ol><li><p>static getDerivedStateFromProps</p></li><li><p>shouldComponentUpdate(nextProps,nextState) 根据返回值决定是否更新，返回 true 时才会调用 render，返回 false 时不会调用 render。默认行为是返回 true ，每次 props 或 state 发生变化都会调用。</p></li><li><p>render()</p></li><li><p>getSnapshotBeforeUpdate(prevProps, prevState) 在组件被更新之前调用，返回值会作为 componentDidUpdate 的第三个参数。</p><p>在最近一次渲染输出（提交到 DOM 节点）之前调用，这个函数运行完真实 DOM 会被渲染。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）</p></li><li><p>componentDidUpdate(prevProps, prevState, snapshot)</p></li></ol><p>卸载阶段</p><ol><li>componentWillUnmount() 在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作</li></ol><h4 id="被废弃的生命周期">被废弃的生命周期</h4><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li></ul><p>原因：</p><p>react 架构或渲染机制改变带来的问题。有副作用，在 render 之前执行，不能保证副作用被清除。</p><h3 id="错误边界">错误边界</h3><p>捕获并打印在子组件的 js 错误，并渲染备用 UI</p><p>在 class 组件中定义 <code>static getDerivedStateFromError</code>或 <code>ComponentDidCatch</code>，然后直接当作常规组件使用，此组件就会形成错误墙(Error Boundary)，错误组件中子组件的错误会被捕获。</p><p>类似在组件层面实现 try catch 机制，一般只需要声明一次，并在整个应用使用。</p><p>错误边界无法捕捉事件处理、异步、服务端渲染、自身错误等非子组件的错误。</p><blockquote><p>事件处理器不会在渲染阶段触发，可以在事件处理内部使用 try catch 语句。</p></blockquote><h3 id="setstate-同步异步问题">setState 同步异步问题</h3><p>本身不是异步的，但在表现上有时同步，有时异步。因为 setState 都会触发更新，将多个状态合并更新，减少渲染次数。</p><p>React 早期（使用 Fiber 架构之前）实现更新批处理导致的，更新优先级的问题，是否处于 batchUpdate。</p><p>在 React 的事件处理函数或 React 生命周期中，state 的更新是异步的，浏览器事件处理结束后批量合并后批量更新。</p><p>在 setTimeout 或原生 dom 事件里是同步更新的。</p><ul><li><a href="https://codesandbox.io/s/setstate-tongbuhuanshiyibu-1bo16?file=/src/App.js">setState 同步还是异步？ - CodeSandbox</a></li></ul><pre><code class="language-jsx" metastring="live">class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }
  componentDidMount() {
    this.setState({ count: this.state.count + 1 });
    console.log(&#x27;1&#x27;, this.state.count);
    this.setState({ count: this.state.count + 1 });
    console.log(&#x27;2&#x27;, this.state.count);
    setTimeout(() =&gt; {
      this.setState({ count: this.state.count + 1 });
      console.log(&#x27;3&#x27;, this.state.count);
    });
    setTimeout(() =&gt; {
      this.setState({ count: this.state.count + 1 });
      console.log(&#x27;4&#x27;, this.state.count);
    });
  }
  render() {
    return &lt;&gt;&lt;/&gt;;
  }
}
</code></pre><h3 id="受控组件">受控组件</h3><p>受控组件：通过组件控制用户输入的值，包括 value,onChange 事件，数据由 react 组件维护。组件对子组件的变更有控制权。</p><p>非受控组件：可以设置 defaultValue，但不能控制值的变更，可以通过 ref 获取当前组件的值。</p><h3 id="状态提升">状态提升</h3><p>几个组件共用状态数据，将这部分状态提升到他们最近的父组件进行管理，并通过 props 传给子组件使用。</p><h3 id="refs">Refs</h3><p>用于父元素访问子元素的方法。也可以用于缓存一个值。</p><h3 id="context">Context</h3><p>跨层级组件数据传递。</p><p>通过组件树传递数据的方法，实现在组件间共享数据，可以避免一层层地手动 props 传递数据。</p><h3 id="组件传值的方式">组件传值的方式</h3><h4 id="父传子">父传子</h4><p>props</p><h4 id="子传父">子传父</h4><p>调用父组件传过来的函数</p><p>class： Refs 拿到子组件的实例，调用其方法</p><p>hooks：forwordRef+useImperativeHandle</p><h4 id="兄弟组件">兄弟组件</h4><p>状态提升到公共祖先，借公共组件传递</p><h4 id="其他">其他</h4><p>context</p><p>redux</p><h3 id="portals-传送门">Portals 传送门</h3><p>将子节点渲染到存在于父组件以外的 DOM 节点，常用于对话框、悬浮卡以及提示框。</p><p><code>ReactDOM.createPortal(child, container)</code> child 是 React 子元素，container 是一个 DOM 元素，child 会渲染到容器里，而不是父类；使用在组件的 render 函数里。</p><p>除了在 DOM 树中的位置，其他行为和普通的 react 子节点行为一致。 react 内的事件处理逻辑等还是在原来的 react 组件中(比如冒泡)</p><h3 id="为什么必须在组件的顶层使用-hook">为什么必须在组件的顶层使用 hook</h3><p>只能在顶层，且不能在循环/条件语句中使用。</p><p>React 内部使用链表，保存每个 hook 调用的顺序，完全依赖 hook 的调用顺序。比如使用多个 useState，需要把每个 state 和对应的 setState 关联。</p><h3 id="fiber-架构">Fiber 架构</h3><p>相对以前的递归更新组件(虚拟 DOM 比较)有优势。递归更新组件会让 JS 调用栈占用很长时间。</p><p>Fiber 将组件分段渲染，建立了一个虚拟栈机制，将各个事件的执行顺序进行优化排序，然后执行。</p><ol><li>解决 DOM 树过深同步渲染整个 DOM 性能下降问题</li><li>将 DOM 拆分渲染，分不同时间片段异步渲染</li><li>由于异步的存在，根据用户行为灵活调整 DOM</li><li>异步渲染导致 render 之前的函数可能执行多次，所有 render 之前的函数都必须是纯函数/static 方法函数</li></ol><h3 id="reconciliation-调和阶段">reconciliation 调和阶段</h3><ol><li>将目标 state 计算出虚拟 DOM 结构。</li><li>DOM diff ，寻找到目标虚拟 DOM 的最优更新方案。</li></ol><p>DOM diff:</p><p>按照深度优先遍历方式，<strong>同层级比较</strong>两棵虚拟 DOM 树。</p><ol><li>无 <strong>key</strong> 时，效率为 O(n)。先对比根元素，根<strong>元素类型</strong>不同就替换为新的，类型相同就比较属性，属性不同就替换为新的，属性相同就比较子元素，比较方式与根元素一致。</li><li>有 <strong>key</strong> 时，新旧虚拟 DOM 对比时，key 相同的进行对比，减少对比次数。</li></ol><p>进行遍历、对比等操作可以中断。</p><h4 id="为什么要使用-key">为什么要使用 key</h4><p>DOM 对比效率。</p><p>key 给每个元素设置一个唯一的标识，用于判断元素时新创建的还是被移动的。</p><h4 id="key-为什么最好不要用-index">key 为什么最好不要用 index</h4><p>相同子元素移动位置会被认为都是新增了，而不是替换了，影响对比效率。</p><h3 id="commit-阶段">commit 阶段</h3><ol><li>对于 reconciliation 协调阶段比较完成后，将获取到的变化部分应用到真实的 DOM 树上。</li><li>调用暴露给用户的钩子方法。比如 ComponentDidUpdate/useLayoutEffect 等。</li></ol><p>要维护较复杂的 DOM 状态，中断后再继续会对用户体验造成影响。一般来说此阶段的耗时比 diff 计算等耗时少。</p><h3 id="调度">调度</h3><p>requestIdleCallback</p><h3 id="react-事件机制">React 事件机制</h3><p>合成事件：基于浏览器的事件机制，React 自身实现的事件机制，包括事件的注册、事件合成、事件冒泡、事件派发等。</p><p>事件代理：React 并不会把事件直接绑定在对应 DOM 上，在 document 上监听所有支持的事件，当事件发生并冒泡到 document 上时，通过 e.target 找到真实的触发元素，React 会封装事件内容给中间层 SyntheticEvent（合成事件）处理。</p><p>当事件触发时，使用统一的分发函数 dispatchEvent 来分发事件。</p><p>不能通过返回 false 阻止默认行为，必须显式使用 preventDefault()。</p><pre><code class="language-jsx" metastring="live">function Button() {
  const handleClick = (e) =&gt; console.log(&#x27;e&#x27;, e.nativeEvent); //e.nativeEvent 上为对应原生事件
  return &lt;button onClick={handleClick}&gt;click&lt;/button&gt;;
}
</code></pre><pre><code class="language-jsx" metastring="live">function EventOrder() {
  const parentRef = useRef();
  const childRef = useRef();
  useEffect(() =&gt; {
    console.log(&#x27;开始挂载&#x27;);
    const parentDom = parentRef.current;
    const childDom = childRef.current;
    function parentClick() {
      console.log(&#x27;原生事件：parent&#x27;);
    }
    function childClick() {
      console.log(&#x27;原生事件：child&#x27;);
    }
    function documentClick(e) {
      console.log(&#x27;原生事件：document&#x27;, e);
    }
    parentDom.addEventListener(&#x27;click&#x27;, parentClick);
    parentDom.addEventListener(&#x27;click&#x27;, childClick);
    document.addEventListener(&#x27;click&#x27;, documentClick);
    return () =&gt; {
      parentDom &amp;&amp; parentDom.removeEventListener(&#x27;click&#x27;, parentClick);
      childDom &amp;&amp; childDom.removeEventListener(&#x27;click&#x27;, childClick);
      document.removeEventListener(&#x27;click&#x27;, documentClick);
    };
  }, []);
  const handleParentClick = () =&gt; {
    console.log(&#x27;React 事件：parent&#x27;);
  };
  const handleChildClick = () =&gt; {
    console.log(&#x27;React 事件： child&#x27;);
  };
  return (
    &lt;div ref={parentRef} onClick={handleParentClick}&gt;
      &lt;div ref={childRef} onClick={handleChildClick}&gt;
        分析事件执行顺序
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>输出顺序：</p><pre><code>开始挂载
原生事件：child
原生事件：parent
React 事件： child
React 事件：parent
原生事件：document
</code></pre><p>真实 DOM 事件先触发，向上冒泡处理父元素 DOM 事件，到达 document 处理 React 事件。最后执行 document 上挂载的事件</p><h4 id="为什么使用合成事件">为什么使用合成事件</h4><p>将所有的事件绑定在 document 上，使用一个事件监听器维持一个映射来保存所有组件内部的事件监听和处理函数，简化事件处理和回收机制。</p><ol><li>一定的兼容问题。</li><li>节省内存，全部挂载 document 上，不用每个元素都挂载。</li><li>事件统一管理：事务机制。</li></ol><h3 id="如何封装组件">如何封装组件</h3><p>接收什么属性</p><p>包含什么状态</p><p>渲染什么结构</p><h3 id="高阶组件">高阶组件</h3><p>接收一个组件，返回一个组件</p><p>封装逻辑复用，常常用于与核心业务无关但又在多个模块使用的功能</p><p>比如：redux connect</p><pre><code class="language-jsx">function withPersistentData(WrappedComponent) {
  return class extends Component {
    componentDidMount() {
      let data = localStorage.getItem(&#x27;data&#x27;);
      this.setState({ data });
    }
    render() {
      // 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent
      return &lt;WrappedComponent data={this.state.data} {...this.props} /&gt;;
    }
  };
}

class MyComponent2 extends Component {
  render() {
    return &lt;div&gt;{this.props.data}&lt;/div&gt;;
  }
}

const MyComponentWithPersistentData = withPersistentData(MyComponent2);
</code></pre><h3 id="如何实现自定义-hook">如何实现自定义 hook</h3><h3 id="react-性能优化">React 性能优化</h3><p>核心：减少不必要的重新渲染。</p><p>良好的组件结构，把变的部分与不变的部分分离，在不使用性能优化 api 的情况下减少重新渲染。</p><p>shouldComponentUpdate/PureComponent/React.memo</p><h3 id="redux">Redux</h3><p>对所有状态进行集中管理的容器。</p><p>当应用变复杂之后，每个组件自己管理状态已经不能满足需求，而 redux 可以做到对应用状态进行集中管理，当需要更新状态时，只需要维护这个集中的状态，而不用关心状态时如何分发到每个组件内部的。</p><p>基本原则：</p><ol><li>单一数据源。整个应用的状态存储在单个 store 内。</li><li>state 只读，改变状态的唯一方法是触发一个动作。</li><li>使用纯函数进行修改。</li></ol><h4 id="工作原理">工作原理</h4><p>数据都存在 store 公共空间，一个组件改变了 store 的数据内容，其他组件就能感知到 store 的变化，取到最新的数据，从而实现统一状态管理的功能。</p><h4 id="工作流">工作流</h4><p><img src="https://img-blog.csdnimg.cn/20210518122733501.png#pic_center" alt="redux 工作流"></p><pre><code class="language-js">//action
{
   type:&quot;SEND_EMAIL&quot;,
   payload: data//可选
}

// action creator 创建action 的函数
export function sendEmail(data) {
    return { type:&quot;SEND_EMAIL&quot;, payload: data};
}

//reducer 接收 action和当前 state，纯函数不会改变 state ，返回新的state
export default function emailReducer(state = [], action){
  switch(action.type) {
      case &quot;SEND_EMAIL&quot;:  return Object.assign({}, state, {
       email: action.payload
      });
      default: return state;
  }
}

</code></pre><h4 id="异步请求">异步请求</h4><p>通过 redux-thunk 中间件处理异步状态管理请求。redux-thunk 允许我们 dispatch 一个包含异步处理逻辑的函数（thunk）。</p><h4 id="redux-中间件">Redux 中间件</h4><p>其实是一个函数，用来扩展 redux 。具体体现在对 action 的处理上，当组件触发一个 action ，会优先被中间件处理，当中间件处理完之后才会把 action 传递给 Reducer。</p><p>常用中间件：</p><ul><li>redux-thunk 处理异步请求</li><li>redux-saga</li><li>redux-actions</li></ul><p>加入中间件后 redux 工作流程：</p><p><img src="https://img-blog.csdnimg.cn/20210519183134715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTgyMjg0,size_16,color_FFFFFF,t_70#pic_center" alt="加入中间件后redux 工作流程"></p><h4 id="react-redux-使用">react-redux 使用</h4><p>react-redux 将组件分成：</p><ul><li><p>容器组件：存在逻辑处理</p></li><li><p>UI 组件：只负责现显示和交互，内部不处理逻辑，状态由外部控制</p></li></ul><p>通过 redux 将整个应用状态存储到 store 中，组件可以派发 dispatch 行为 action 给 store，其他组件通过订阅 store 中的状态 state 来更新自身的视图</p><p>组件使用：</p><pre><code class="language-jsx">import { Provider } from &quot;react-redux&quot;;
&lt;Provider store = {store}&gt;
    &lt;App /&gt;
&lt;Provider&gt;
</code></pre><pre><code class="language-jsx">import { connect } from &quot;react-redux&quot;;

function User (props) {
  handleSubmit() {
    // dispatch an action
    props.sendEmail(this.state.email);
  }
}
// you are mapping you state props
const mapStateToProps = (state, ownProps) =&gt; ({ user: state.user });
// you are binding your action creators to your props
const mapDispatchToProps = (dispatch) =&gt; ({ sendEmailDispatch(data){
   dispatch(sendEmail(data))
} });

export default connect(mapStateToProps, mapDispatchToProps)(User);
</code></pre><h4 id="项目组织方式">项目组织方式</h4><ol><li>按角色组织</li></ol><pre><code>reducers/
  todoReducer.js
  filterReducer.js
actions/
  todoAction.js
  filterActions.js
components/
  todoList.js
  todoItem.js
  filter.js
containers/
  todoListContainer.js
  todoItemContainer.js
  filterContainer.js
</code></pre><ol start="2"><li>按业务模块组织</li></ol><pre><code>todoList/
  actions.js //定义 action创建函数
  actionTypes.js //定义 action 类型
  index.js //把所有的角色导入，统一导出
  reducer.js //响应actions的动作
  views/ //功能模块中所有的React组件，包括展示组件和容器组件
    components.js
    containers.js
filter/
  actions.js
  actionTypes.js
  index.js
  reducer.js
  views/
    components.js
    container.js
</code></pre><h2 id="相关生态常用的库">相关生态，常用的库</h2><h3 id="动画">动画</h3><ul><li><a href="https://react-spring.io/">react-spring</a></li></ul><h2 id="future-learning">Future Learning</h2><p>//todo:</p><ul><li><a href="https://juejin.cn/post/7075701341997236261#heading-5">React Hooks 的原理，有的简单有的不简单 - 掘金</a></li><li><a href="https://www.yuque.com/lxylona/note/nz6gk4">Hooks 数据流 · 语雀</a></li></ul><h2 id="references">References</h2><ul><li><a href="https://mp.weixin.qq.com/s/w33yWPg-CO0FBAZbPS_gdg">【微信公众号：JS 每日一题 2021-07-16 08:31】说说你对 Redux 的理解？其工作原理？</a></li><li><a href="https://mp.weixin.qq.com/s/fJqZqgQQkHyBjdnnyUB5uA">【微信公众号：JS 每日一题 2021-07-20 08:31】面试官：你在 React 项目中是如何使用 Redux 的? 项目结构是如何划分的？</a></li><li><a href="https://mp.weixin.qq.com/s/33iiPeWUyNTtGxN5UkZ5xA">【微信公众号：JS 每日一题 2021-07-12 08:31】面试官：说说对高阶组件的理解？应用场景?</a></li><li><a href="https://mp.weixin.qq.com/s/gKYU8rIXPM5qiItxuu_HMw">【微信公众号：JS 每日一题 2021-06-30 08:31】面试官：说说对 React 事件机制的理解？</a></li></ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/brightzoe/brightzoe.github.io/edit/main/docs/react/README.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_qT5X" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated__3SG"><span class="theme-last-updated">Last updated<!-- --> on <b><time datetime="2023-08-04T10:38:39.000Z">Aug 4, 2023</time></b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--next" href="/docs/react/hooks"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">React Hooks</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_saGL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#react-与-react-dom库" class="table-of-contents__link toc-highlight"><code>react</code> 与 <code>react-dom</code>库</a></li><li><a href="#react-router-与-react-router-dom库" class="table-of-contents__link toc-highlight"><code>react-router</code> 与 <code>react-router-dom</code>库</a></li><li><a href="#问题汇总" class="table-of-contents__link toc-highlight">问题汇总</a><ul><li><a href="#react-特点" class="table-of-contents__link toc-highlight">React 特点</a></li><li><a href="#虚拟-dom" class="table-of-contents__link toc-highlight">虚拟 DOM</a></li><li><a href="#class-comp-与-function-comp" class="table-of-contents__link toc-highlight">Class Comp 与 Function Comp</a></li><li><a href="#使用区别" class="table-of-contents__link toc-highlight">使用区别</a></li><li><a href="#react-元素与组件" class="table-of-contents__link toc-highlight">React 元素与组件</a></li><li><a href="#purecomponent" class="table-of-contents__link toc-highlight">PureComponent</a></li><li><a href="#生命周期" class="table-of-contents__link toc-highlight">生命周期</a><ul><li><a href="#被废弃的生命周期" class="table-of-contents__link toc-highlight">被废弃的生命周期</a></li></ul></li><li><a href="#错误边界" class="table-of-contents__link toc-highlight">错误边界</a></li><li><a href="#setstate-同步异步问题" class="table-of-contents__link toc-highlight">setState 同步异步问题</a></li><li><a href="#受控组件" class="table-of-contents__link toc-highlight">受控组件</a></li><li><a href="#状态提升" class="table-of-contents__link toc-highlight">状态提升</a></li><li><a href="#refs" class="table-of-contents__link toc-highlight">Refs</a></li><li><a href="#context" class="table-of-contents__link toc-highlight">Context</a></li><li><a href="#组件传值的方式" class="table-of-contents__link toc-highlight">组件传值的方式</a><ul><li><a href="#父传子" class="table-of-contents__link toc-highlight">父传子</a></li><li><a href="#子传父" class="table-of-contents__link toc-highlight">子传父</a></li><li><a href="#兄弟组件" class="table-of-contents__link toc-highlight">兄弟组件</a></li><li><a href="#其他" class="table-of-contents__link toc-highlight">其他</a></li></ul></li><li><a href="#portals-传送门" class="table-of-contents__link toc-highlight">Portals 传送门</a></li><li><a href="#为什么必须在组件的顶层使用-hook" class="table-of-contents__link toc-highlight">为什么必须在组件的顶层使用 hook</a></li><li><a href="#fiber-架构" class="table-of-contents__link toc-highlight">Fiber 架构</a></li><li><a href="#reconciliation-调和阶段" class="table-of-contents__link toc-highlight">reconciliation 调和阶段</a><ul><li><a href="#为什么要使用-key" class="table-of-contents__link toc-highlight">为什么要使用 key</a></li><li><a href="#key-为什么最好不要用-index" class="table-of-contents__link toc-highlight">key 为什么最好不要用 index</a></li></ul></li><li><a href="#commit-阶段" class="table-of-contents__link toc-highlight">commit 阶段</a></li><li><a href="#调度" class="table-of-contents__link toc-highlight">调度</a></li><li><a href="#react-事件机制" class="table-of-contents__link toc-highlight">React 事件机制</a><ul><li><a href="#为什么使用合成事件" class="table-of-contents__link toc-highlight">为什么使用合成事件</a></li></ul></li><li><a href="#如何封装组件" class="table-of-contents__link toc-highlight">如何封装组件</a></li><li><a href="#高阶组件" class="table-of-contents__link toc-highlight">高阶组件</a></li><li><a href="#如何实现自定义-hook" class="table-of-contents__link toc-highlight">如何实现自定义 hook</a></li><li><a href="#react-性能优化" class="table-of-contents__link toc-highlight">React 性能优化</a></li><li><a href="#redux" class="table-of-contents__link toc-highlight">Redux</a><ul><li><a href="#工作原理" class="table-of-contents__link toc-highlight">工作原理</a></li><li><a href="#工作流" class="table-of-contents__link toc-highlight">工作流</a></li><li><a href="#异步请求" class="table-of-contents__link toc-highlight">异步请求</a></li><li><a href="#redux-中间件" class="table-of-contents__link toc-highlight">Redux 中间件</a></li><li><a href="#react-redux-使用" class="table-of-contents__link toc-highlight">react-redux 使用</a></li><li><a href="#项目组织方式" class="table-of-contents__link toc-highlight">项目组织方式</a></li></ul></li></ul></li><li><a href="#相关生态常用的库" class="table-of-contents__link toc-highlight">相关生态，常用的库</a><ul><li><a href="#动画" class="table-of-contents__link toc-highlight">动画</a></li></ul></li><li><a href="#future-learning" class="table-of-contents__link toc-highlight">Future Learning</a></li><li><a href="#references" class="table-of-contents__link toc-highlight">References</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">博客推荐</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://sadofriod.github.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Ashes Born&#x27;s Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_o1MT"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://overreacted.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Overreacted - Dan Abramov<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_o1MT"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">  </div><ul class="footer__items clean-list"></ul></div><div class="col footer__col"><div class="footer__title">博客推荐</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://sadofriod.github.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Ashes Born&#x27;s Blog<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_o1MT"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://overreacted.io/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Overreacted - Dan Abramov<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_o1MT"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 brightzoe's blog</div></div></div></footer></div>
<script src="/assets/js/runtime~main.ef263209.js"></script>
<script src="/assets/js/main.6c773390.js"></script>
</body>
</html>